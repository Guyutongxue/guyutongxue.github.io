<!DOCTYPE html>
<html>
<head>
<title>noip2017</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<link rel="stylesheet" type="text/css" href="/css/github-markdown.css">
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<h1>NOIP 2017 总结</h1>
<p align="right">
谷雨同学 2017年11月14日-15日<br>
最后更新于2018年1月8日
</p>
<h2>总述</h2>
<p>这是我第一次参加 NOIP 。</p>
<p>总分355。下面是当时估分写的总结</p>
<blockquote>
<p>我只不过刚刚学了一年而已，关于算法竞赛只是了解些皮毛而已。今天早些时候我拿到了我的源代码，于是便立即在<a href="https://www.luogu.org/" rel="nofollow">洛谷</a>上用<a href="https://www.luogu.org/contestnew/show/4442" rel="nofollow">“民间数据”</a>自测了一下。现汇报如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>题目</th>
<th align="right">估计分数</th>
<th align="right">实际分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>math</td>
<td align="right">100</td>
<td align="right">100</td>
</tr>
<tr>
<td>complexity</td>
<td align="right">100</td>
<td align="right">100</td>
</tr>
<tr>
<td>park</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr>
<td>cheese</td>
<td align="right">100</td>
<td align="right">70</td>
</tr>
<tr>
<td>treasure</td>
<td align="right">80</td>
<td align="right">55</td>
</tr>
<tr>
<td>phalanx</td>
<td align="right">30</td>
<td align="right">30</td>
</tr>
<tr>
<td><strong>总分</strong></td>
<td align="right"><strong>410</strong></td>
<td align="right"><strong>355</strong></td>
</tr></tbody></table>
<h2>math - 小凯的疑惑</h2>
<p>上来第一题就是数学让我感到措手不及。我只好一点点列举，然后找规律......<br>
比如我看到 \( 14=3\times 0+7\times 2 \) 时，便意识到11之所以被输出，是因为实际上 \( 11=3\times ( -1 ) +7\times 2 \) ,但是 -1 不合法。以此为突破口，我首先试着循环 <code>1 .. a</code> ，然后对于每一个数不断累加 <code>a</code> 判断那一个最晚被 <code>b</code> 整除，再减去 <code>a</code> 求得答案，此时时间复杂度为 \( \Theta(ab) \)。后来又发现先找到的被整除的数其实就是 \(a \times(b-1)\) ，所以答案就是</p>
<div align="center"> $$ a \times b - a - b $$ </div>
<h4>源代码</h4>
<p>100分， AC 。中间的大部分都注释掉了。</p>
<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstdio<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstring<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">long</span> <span class="pl-k">long</span> a,b;
<span class="pl-k">int</span> <span class="pl-en">main</span>(){
	<span class="pl-c1">ios::sync_with_stdio</span>(<span class="pl-c1">false</span>);
	#<span class="pl-k">ifndef</span> LOCAL
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>math.in<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>,stdin);
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>math.out<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">endif</span>
	cin&gt;&gt;a&gt;&gt;b;
	<span class="pl-k">if</span>(a&gt;b)<span class="pl-c1">swap</span>(a,b);
	<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">	long long ans=-1;</span>
<span class="pl-c">	for(long long i=1;i&lt;a;i++){</span>
<span class="pl-c">		long long c=i,j=0;</span>
<span class="pl-c">		while(c%b){</span>
<span class="pl-c">			c+=a;</span>
<span class="pl-c">			j++;</span>
<span class="pl-c">		}</span>
<span class="pl-c">		ans=max(ans,i+a*(j-1));</span>
<span class="pl-c">	}</span>
<span class="pl-c">	cout&lt;&lt;ans&lt;&lt;endl;</span>
<span class="pl-c">	<span class="pl-c">*/</span></span>
	<span class="pl-k">long</span> <span class="pl-k">long</span> ans=b*(a-<span class="pl-c1">1</span>)-a;
	cout&lt;&lt;ans&lt;&lt;endl;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>complexity - 时间复杂度</h2>
<p>这是一个非常复杂的模拟。我最初没有想到用栈，于是思路就是先读入全部指令，然后逐行执行：设置一个 work 变量，记录当前光标执行到的循环体编号。然后读到“ F ”行将 work 设为一个新开循环体编号同时记录它的父亲编号。读到“ E ”行将 work 退回父亲编号。所以每一个循环体就是如下结构：</p>
<div class="highlight highlight-source-c++"><pre><span class="pl-k">struct</span> <span class="pl-en">xht</span>{
    <span class="pl-k">int</span> par;<span class="pl-c"><span class="pl-c">//</span>父亲编号</span>
    <span class="pl-k">int</span> v;<span class="pl-c"><span class="pl-c">//</span>时间复杂度对数</span>
};</pre></div>
<p>关于处理时间复杂度：用对数记录即可。输入的处理方式是截取 <code>[2]</code> 处字符，若为 <code>'1'</code> 则返回 \( \log_{n}1 \) ,否则把 <code>[4]..size()-2</code> 区间的字符转为数字，即为\( \log_{n}\Theta \) 。转换为数字的方法是用 <code>stringstream</code> ，输入一个字符串再对一个整型输出即可。（这是我头一次用这种方法）</p>
<p>然后判断循环变量是否使用（已使用输出 <code>ERR</code> )。再判断初值和末值的关系，共有五种情况，我用了一个函数判断：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>情况</th>
<th>时间复杂度对数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>n~n</td>
<td>等于父亲循环体</td>
</tr>
<tr>
<td>2</td>
<td>n~常数</td>
<td>不存在</td>
</tr>
<tr>
<td>3</td>
<td>常数~n</td>
<td>等于父亲循环体+1</td>
</tr>
<tr>
<td>4</td>
<td>常数~常数，且前者小于后者</td>
<td>等于父亲循环体+1</td>
</tr>
<tr>
<td>5</td>
<td>常数~常数，且前者大于后者</td>
<td>不存在</td>
</tr></tbody></table>
<p>这样就可以找到光标经过每一个循环体的时间复杂度，找到其最大值和输入的比较即可。</p>
<h4>源代码</h4>
<p>100分， AC 。其中 <code>xht</code> 结构体中的 <code>no</code> 成员是没有用的，忘记删除了。</p>
<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstring<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>sstream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>string<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstdio<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">int</span> t;
<span class="pl-k">bool</span> used[<span class="pl-c1">30</span>];
string cmd[<span class="pl-c1">102</span>];
<span class="pl-k">struct</span> <span class="pl-en">xht</span>{
	<span class="pl-k">int</span> no;
	<span class="pl-k">int</span> par;
	<span class="pl-k">int</span> v;
};
xht f[<span class="pl-c1">52</span>];
<span class="pl-k">int</span> <span class="pl-en">toInt</span>(string x){
	stringstream a;
	<span class="pl-k">int</span> b;
	a&lt;&lt;x;
	a&gt;&gt;b;
	<span class="pl-k">return</span> b;
}
<span class="pl-k">int</span> <span class="pl-en">getO</span>(string x){
	<span class="pl-k">if</span>(x[<span class="pl-c1">2</span>]==<span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>)<span class="pl-k">return</span> <span class="pl-c1">0</span>;
	string y;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">4</span>;i&lt;x.<span class="pl-c1">size</span>()-<span class="pl-c1">1</span>;i++){
		y+=x[i];
	}
	<span class="pl-k">return</span> <span class="pl-c1">toInt</span>(y);
}
<span class="pl-k">void</span> <span class="pl-en">getDtl</span>(string src,<span class="pl-k">char</span>&amp; a,string&amp; b,string&amp; c){
	stringstream x;
	x&lt;&lt;src;
	x&gt;&gt;src&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	<span class="pl-k">return</span>;
}
<span class="pl-k">int</span> <span class="pl-en">als</span>(string x,string y){
	<span class="pl-k">if</span>(x==<span class="pl-s"><span class="pl-pds">"</span>n<span class="pl-pds">"</span></span>){
		<span class="pl-k">if</span>(y==<span class="pl-s"><span class="pl-pds">"</span>n<span class="pl-pds">"</span></span>)<span class="pl-k">return</span> <span class="pl-c1">0</span>;
		<span class="pl-k">return</span> <span class="pl-c1">1</span>;
	}
	<span class="pl-k">if</span>(y==<span class="pl-s"><span class="pl-pds">"</span>n<span class="pl-pds">"</span></span>)<span class="pl-k">return</span> <span class="pl-c1">2</span>;
	<span class="pl-k">if</span>(<span class="pl-c1">toInt</span>(x)&lt;=<span class="pl-c1">toInt</span>(y))<span class="pl-k">return</span> <span class="pl-c1">3</span>;
	<span class="pl-k">return</span> <span class="pl-c1">4</span>;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>(){
	<span class="pl-c1">ios::sync_with_stdio</span>(<span class="pl-c1">false</span>);
	#<span class="pl-k">ifndef</span> LOCAL
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>complexity.in<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>,stdin);
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>complexity.out<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">else</span>
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>out.txt<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">endif</span>
	cin&gt;&gt;t;
	<span class="pl-k">while</span>(t--){
		<span class="pl-k">int</span> l,o,cnt=<span class="pl-c1">0</span>,ans=<span class="pl-c1">0</span>;
		<span class="pl-c1">memset</span>(used,<span class="pl-c1">false</span>,<span class="pl-k">sizeof</span>(used));
		<span class="pl-c1">memset</span>(f,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(f));
		<span class="pl-k">int</span> work=<span class="pl-c1">0</span>;
		string oo;
		cin&gt;&gt;l&gt;&gt;oo;
		o=<span class="pl-c1">getO</span>(oo);
		<span class="pl-c1">getline</span>(cin,oo);
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=l;i++){
			<span class="pl-c1">getline</span>(cin,cmd[i]);
		}
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=l;i++){
			<span class="pl-k">if</span>(cmd[i][<span class="pl-c1">0</span>]==<span class="pl-s"><span class="pl-pds">'</span>F<span class="pl-pds">'</span></span>){
				<span class="pl-k">char</span> a;
				string b,c;
				<span class="pl-c1">getDtl</span>(cmd[i],a,b,c);
				<span class="pl-k">if</span>(used[a-<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>]){
					cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>ERR<span class="pl-pds">"</span></span>&lt;&lt;endl;
					<span class="pl-k">goto</span> out;
				}
				f[++cnt].<span class="pl-smi">no</span>=a-<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>;
				used[f[cnt].<span class="pl-smi">no</span>]=<span class="pl-c1">true</span>;
				f[cnt].<span class="pl-smi">par</span>=work;
				work=cnt;
				<span class="pl-k">switch</span>(<span class="pl-c1">als</span>(b,c)){
					<span class="pl-k">case</span> <span class="pl-c1">0</span>:{<span class="pl-c"><span class="pl-c">//</span>n,n</span>
						f[cnt].<span class="pl-smi">v</span>=f[f[cnt].<span class="pl-smi">par</span>].<span class="pl-smi">v</span>;
						<span class="pl-k">break</span>;
					}
					<span class="pl-k">case</span> <span class="pl-c1">1</span>:{<span class="pl-c"><span class="pl-c">//</span>n,_</span>
						f[cnt].<span class="pl-smi">v</span>=-<span class="pl-c1">1</span>;
						<span class="pl-k">break</span>;
					}
					<span class="pl-k">case</span> <span class="pl-c1">2</span>:{<span class="pl-c"><span class="pl-c">//</span>_,n</span>
						f[cnt].<span class="pl-smi">v</span>=(f[f[cnt].<span class="pl-smi">par</span>].<span class="pl-smi">v</span>==-<span class="pl-c1">1</span>?-<span class="pl-c1">1</span>:f[f[cnt].<span class="pl-smi">par</span>].<span class="pl-smi">v</span>+<span class="pl-c1">1</span>);
						<span class="pl-k">break</span>;
					}
					<span class="pl-k">case</span> <span class="pl-c1">3</span>:{<span class="pl-c"><span class="pl-c">//</span>small.big</span>
						f[cnt].<span class="pl-smi">v</span>=f[f[cnt].<span class="pl-smi">par</span>].<span class="pl-smi">v</span>;
						<span class="pl-k">break</span>;
					}
					<span class="pl-k">case</span> <span class="pl-c1">4</span>:{<span class="pl-c"><span class="pl-c">//</span>big,small</span>
						f[cnt].<span class="pl-smi">v</span>=-<span class="pl-c1">1</span>;
						<span class="pl-k">break</span>;
					}
				}
				ans=<span class="pl-c1">max</span>(ans,f[work].<span class="pl-smi">v</span>);
			}
			<span class="pl-k">else</span>{
				used[f[work].<span class="pl-smi">no</span>]=<span class="pl-c1">false</span>;
				<span class="pl-k">if</span>(work==<span class="pl-c1">0</span>){
					cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>ERR<span class="pl-pds">"</span></span>&lt;&lt;endl;
					<span class="pl-k">goto</span> out;
				}
				work=f[work].<span class="pl-smi">par</span>;
			}
		}
		<span class="pl-k">if</span>(work){
			cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>ERR<span class="pl-pds">"</span></span>&lt;&lt;endl;
			<span class="pl-k">continue</span>;
		}
		cout&lt;&lt;(ans==o?<span class="pl-s"><span class="pl-pds">"</span>Yes<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>No<span class="pl-pds">"</span></span>)&lt;&lt;endl;
		out:;
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>park - 逛公园</h2>
<p>没做。由于第二题花了我太长的时间，所以第三题几乎没有什么时间了。再者图论我也不熟悉，恐怕做也做不出来。</p>
<p>0分。</p>
<h2>cheese - 奶酪</h2>
<p>用了一个DFS做出来的。首先在输入的同时用布尔型“邻接矩阵” <code>e[][]</code> 来记录两个洞是否相连，并判断是否通底部或顶部。如果通底部，把这个洞加入数组 <code>btm[]</code> 中，如果同顶部将 <code>top[]</code> 设为 <code>true</code> 。<br>
再从 <code>btm[]</code> 中逐个DFS搜索，如果能搜到顶返回 <code>"Yes"</code> ,否则就是 <code>"No"</code> 。</p>
<blockquote>
<p>然而这道题还是踩了个坑，因为判断是否连通时会超 <code>long long</code> 范围。坐标极值为 \( \pm 10^{9} \) ,坐标之差最大值为 \( 2 \times 10^{9} \) , 带入距离公式则根号下最大值为 \( 3 \times ( 2 \times 10^{9} )^{2} = 3 \times 4 \times 10^{18} = 1.2 \times 10^{19} \) 。而 <code>long long</code> 的最大值为 \( 9 \, 223 \, 372 \, 036 \, 854 \, 775 \, 807 = 9.22 \times 10^{18} &lt; 1.2 \times 10^{19} \) 。所以只能说洛谷的数据有点水，真正的得分应该到不了 AC 。</p>
</blockquote>
<p>是啊，一个 <code>unsigned</code> 扣了我30分...</p>
<h4>源代码</h4>
<p>70分， AC 。</p>
<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstring<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstdio<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>

<span class="pl-k">int</span> t;
<span class="pl-k">int</span> n,h,r;
<span class="pl-k">bool</span> e[<span class="pl-c1">1002</span>][<span class="pl-c1">1002</span>];
<span class="pl-k">bool</span> m[<span class="pl-c1">1002</span>];
<span class="pl-k">bool</span> top[<span class="pl-c1">1002</span>];
<span class="pl-k">int</span> btm[<span class="pl-c1">1002</span>];
<span class="pl-k">int</span> lb;
<span class="pl-k">struct</span> <span class="pl-en">hole</span>{
	<span class="pl-k">int</span> x;
	<span class="pl-k">int</span> y;
	<span class="pl-k">int</span> z;
};
hole o[<span class="pl-c1">1002</span>];

<span class="pl-k">bool</span> <span class="pl-en">isLinked</span>(hole a,hole b,<span class="pl-k">int</span> d){
	<span class="pl-k">long</span> <span class="pl-k">long</span> dl=d*d;
	<span class="pl-k">long</span> <span class="pl-k">long</span> rr=<span class="pl-c1">0</span>;
	rr+=(a.<span class="pl-smi">x</span>-b.<span class="pl-smi">x</span>)*(a.<span class="pl-smi">x</span>-b.<span class="pl-smi">x</span>);
	rr+=(a.<span class="pl-smi">y</span>-b.<span class="pl-smi">y</span>)*(a.<span class="pl-smi">y</span>-b.<span class="pl-smi">y</span>);
	rr+=(a.<span class="pl-smi">z</span>-b.<span class="pl-smi">z</span>)*(a.<span class="pl-smi">z</span>-b.<span class="pl-smi">z</span>);
	<span class="pl-k">return</span> rr&lt;=dl;
}
<span class="pl-k">bool</span> <span class="pl-en">find</span>(<span class="pl-k">int</span> x){
	<span class="pl-k">if</span>(m[x])<span class="pl-k">return</span> <span class="pl-c1">false</span>;
	m[x]=<span class="pl-c1">true</span>;
	<span class="pl-k">if</span>(top[x])<span class="pl-k">return</span> <span class="pl-c1">true</span>;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=n;i++){
		<span class="pl-k">if</span>(e[x][i]){
			<span class="pl-k">if</span>(<span class="pl-c1">find</span>(i))<span class="pl-k">return</span> <span class="pl-c1">true</span>;
		}
	}
	<span class="pl-k">return</span> <span class="pl-c1">false</span>;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>(){
	<span class="pl-c1">ios::sync_with_stdio</span>(<span class="pl-c1">false</span>);
	#<span class="pl-k">ifndef</span> LOCAL
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>cheese.in<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>,stdin);
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>cheese.out<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">else</span>
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>in.txt<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>,stdin);
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>out.txt<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">endif</span>
	cin&gt;&gt;t;
	<span class="pl-k">while</span>(t--){
		<span class="pl-c1">memset</span>(o,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(o));
		<span class="pl-c1">memset</span>(e,<span class="pl-c1">false</span>,<span class="pl-k">sizeof</span>(e));
		<span class="pl-c1">memset</span>(top,<span class="pl-c1">false</span>,<span class="pl-k">sizeof</span>(top));
		<span class="pl-c1">memset</span>(btm,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(btm));
		<span class="pl-c1">memset</span>(m,<span class="pl-c1">false</span>,<span class="pl-k">sizeof</span>(m));
		cin&gt;&gt;n&gt;&gt;h&gt;&gt;r;
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=n;i++){
			cin&gt;&gt;o[i].<span class="pl-smi">x</span>&gt;&gt;o[i].<span class="pl-smi">y</span>&gt;&gt;o[i].<span class="pl-smi">z</span>;
			<span class="pl-k">if</span>(o[i].<span class="pl-smi">z</span>+r&gt;=h)top[i]=<span class="pl-c1">true</span>;
			<span class="pl-k">if</span>(o[i].<span class="pl-smi">z</span>-r&lt;=<span class="pl-c1">0</span>)btm[++lb]=i;
			<span class="pl-k">for</span>(<span class="pl-k">int</span> j=<span class="pl-c1">1</span>;j&lt;i;j++){
				<span class="pl-k">bool</span> isL=<span class="pl-c1">isLinked</span>(o[i],o[j],<span class="pl-c1">2</span>*r);
				e[i][j]=e[j][i]=isL;
			}
		}
		<span class="pl-c"><span class="pl-c">/*</span></span>
<span class="pl-c">		for(int i=1;i&lt;=n;i++){</span>
<span class="pl-c">			for(int j=1;j&lt;=n;j++){</span>
<span class="pl-c">				cout&lt;&lt;e[i][j];</span>
<span class="pl-c">			}</span>
<span class="pl-c">			cout&lt;&lt;endl;</span>
<span class="pl-c">		}</span>
<span class="pl-c">		<span class="pl-c">*/</span></span>
		<span class="pl-c"><span class="pl-c">//</span>cout&lt;&lt;lb&lt;&lt;btm[1]&lt;&lt;endl;</span>
		<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=lb;i++){
			<span class="pl-k">if</span>(<span class="pl-c1">find</span>(btm[i])){
				cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Yes<span class="pl-pds">"</span></span>&lt;&lt;endl;
				<span class="pl-k">goto</span> out;
			}
		}
		cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>No<span class="pl-pds">"</span></span>&lt;&lt;endl;
		out:;
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>treasure - 宝藏</h2>
<p>呃......这个题，我是没有思路的。经过一段时间的观察发现：我可以建立一个集合 <code>hv[]</code> 表示已遍历的点以及一个集合 <code>work[]</code> 容纳边。先以第一个点为起点，加进 <code>hv[]</code> ，把与它相连的边加入 <code>work[]</code> ，然后选取边长 * 深度最短的一条退出 <code>work[]</code> ，把所指向的点加进集合 <code>hv[]</code> ，将与这个点相连的所有边加入 <code>work[]</code> 。这样往复操作直到所有的点都加入 <code>hv[]</code> 后，再以第二个作为起点执行一遍，直到全部执行完成，输出选中的“边长 * 深度”之和的最小值，就和样例的输出是一样的。</p>
<blockquote>
<p>至于为什么是这样的我不知道，所以 WA 了 4 个点也就不足为怪了。不过已经很知足了。</p>
</blockquote>
<p>知足了，瞎写一通还能55分。</p>
<h4>源代码</h4>
<p>代码写的很乱，因为邻接表用的不熟练，导致无向边和有向边不统一，设了一堆乱七八糟的数组......</p>
<p>55分， WA 。</p>
<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstring<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstdio<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">int</span> n,m;
<span class="pl-k">int</span> l[<span class="pl-c1">1002</span>];
<span class="pl-k">int</span> s[<span class="pl-c1">15</span>];
<span class="pl-k">int</span> em[<span class="pl-c1">2004</span>];
<span class="pl-k">bool</span> work[<span class="pl-c1">1002</span>];
<span class="pl-k">int</span> hv[<span class="pl-c1">15</span>];
<span class="pl-k">int</span> to[<span class="pl-c1">1002</span>];
<span class="pl-k">int</span> by[<span class="pl-c1">1002</span>];
<span class="pl-k">int</span> ans=<span class="pl-c1">0</span>,res=(<span class="pl-c1">1</span>&lt;&lt;<span class="pl-c1">30</span>);
<span class="pl-c"><span class="pl-c">//</span>-------------LJB------------</span>
<span class="pl-k">int</span> next[<span class="pl-c1">2002</span>];
<span class="pl-k">int</span> dot[<span class="pl-c1">15</span>];
<span class="pl-k">int</span> edge[<span class="pl-c1">2002</span>];
<span class="pl-k">int</span> cnt=<span class="pl-c1">0</span>;
<span class="pl-k">void</span> <span class="pl-en">addedge</span>(<span class="pl-k">int</span> x,<span class="pl-k">int</span> y,<span class="pl-k">int</span> i){
	edge[++cnt]=y;
	next[cnt]=dot[x];
	dot[x]=cnt;
	em[cnt]=i;
}

<span class="pl-k">void</span> <span class="pl-en">debug</span>(){
	cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>work:<span class="pl-pds">"</span></span>;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=m;i++){
		cout&lt;&lt;work[i]&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
	}
	cout&lt;&lt;endl&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>by:<span class="pl-pds">"</span></span>;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=m;i++){
		cout&lt;&lt;by[i]&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
	}
	cout&lt;&lt;endl&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>to:<span class="pl-pds">"</span></span>;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=m;i++){
		cout&lt;&lt;to[i]&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
	}
	cout&lt;&lt;endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>(){
	<span class="pl-c1">ios::sync_with_stdio</span>(<span class="pl-c1">false</span>);
	#<span class="pl-k">ifndef</span> LOCAL
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>treasure.in<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>,stdin);
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>treasure.out<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">endif</span>
	cin&gt;&gt;n&gt;&gt;m;
	<span class="pl-c1">memset</span>(l,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(l));
	<span class="pl-c1">memset</span>(dot,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(dot));
	<span class="pl-c1">memset</span>(edge,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(edge));
	<span class="pl-c1">memset</span>(next,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(next));
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=m;i++){
		<span class="pl-k">int</span> a,b,c;
		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
		<span class="pl-c1">addedge</span>(a,b,i);
		<span class="pl-c1">addedge</span>(b,a,i);
		l[i]=c;
	}
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=n;i++){
		ans=<span class="pl-c1">0</span>;
		<span class="pl-c1">memset</span>(work,<span class="pl-c1">false</span>,<span class="pl-k">sizeof</span>(work));
		<span class="pl-c1">memset</span>(by,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(by));
		<span class="pl-c1">memset</span>(to,<span class="pl-c1">0</span>,<span class="pl-k">sizeof</span>(to));
		<span class="pl-c1">memset</span>(hv,<span class="pl-c1">false</span>,<span class="pl-k">sizeof</span>(hv));
		hv[i]=<span class="pl-c1">true</span>;
		<span class="pl-k">for</span>(<span class="pl-k">int</span> j=dot[i];j;j=next[j]){
			<span class="pl-c"><span class="pl-c">//</span>cout&lt;&lt;i&lt;&lt;" "&lt;&lt;edge[j]&lt;&lt;" "&lt;&lt;em[j]&lt;&lt;":"&lt;&lt;l[em[j]]&lt;&lt;endl;</span>
			work[em[j]]=<span class="pl-c1">true</span>;
			by[em[j]]=<span class="pl-c1">1</span>;
			to[em[j]]=edge[j];
		}
		<span class="pl-k">int</span> x=<span class="pl-c1">1</span>;
		
		<span class="pl-k">while</span>(x&lt;n){
			<span class="pl-c"><span class="pl-c">//</span>debug();</span>
			<span class="pl-k">int</span> sno=<span class="pl-c1">500002</span>,nx,bb;
			<span class="pl-k">for</span>(<span class="pl-k">int</span> j=<span class="pl-c1">1</span>;j&lt;=m;j++){
				<span class="pl-k">if</span>(work[j]&amp;&amp;!hv[to[j]]){
					<span class="pl-k">if</span>(sno&gt;l[j]*by[j]){
						sno=l[j]*by[j];
						nx=to[j];
						bb=by[j];
					}
				}
			}
			<span class="pl-c"><span class="pl-c">//</span>cout&lt;&lt;sno&lt;&lt;" "&lt;&lt;nx&lt;&lt;" "&lt;&lt;bb&lt;&lt;endl;</span>
			ans+=sno;
			hv[nx]=<span class="pl-c1">true</span>;
			x++;
			<span class="pl-k">for</span>(<span class="pl-k">int</span> j=dot[nx];j;j=next[j]){
				<span class="pl-k">if</span>(!hv[edge[j]]){
					work[em[j]]=<span class="pl-c1">true</span>;
					by[em[j]]=bb+<span class="pl-c1">1</span>;
					to[em[j]]=edge[j];
				}
			}
		}
		res=<span class="pl-c1">min</span>(res,ans);
	}
	cout&lt;&lt;res&lt;&lt;endl;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>phalanx - 方阵</h2>
<p>无思路，写了个暴力。用二元数组 <code>a[][]</code> 表示这一点的编号。</p>
<h4>源代码</h4>
<p>30分， RE 。</p>
<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstring<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>cstdio<span class="pl-pds">&gt;</span></span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-k">int</span> a[<span class="pl-c1">10002</span>][<span class="pl-c1">10002</span>];
<span class="pl-k">int</span> n,m,q;
<span class="pl-k">void</span> <span class="pl-en">debug</span>(){
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=n;i++){
		<span class="pl-k">for</span>(<span class="pl-k">int</span> j=<span class="pl-c1">1</span>;j&lt;=m;j++){
			cout&lt;&lt;a[i][j]&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
		}
		cout&lt;&lt;endl;
	}
}
<span class="pl-k">int</span> <span class="pl-en">main</span>(){
	<span class="pl-c1">ios::sync_with_stdio</span>(<span class="pl-c1">false</span>);
	#<span class="pl-k">ifndef</span> LOCAL
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>phalanx.in<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>,stdin);
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>phalanx.out<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">else</span>
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>in.txt<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>,stdin);
	<span class="pl-c1">freopen</span>(<span class="pl-s"><span class="pl-pds">"</span>out.txt<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>,stdout);
	#<span class="pl-k">endif</span>
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=n;i++){
		<span class="pl-k">for</span>(<span class="pl-k">int</span> j=<span class="pl-c1">1</span>;j&lt;=m;j++){
			a[i][j]=(i-<span class="pl-c1">1</span>)*m+j;
		}
	}
	<span class="pl-c"><span class="pl-c">//</span>debug();</span>
	<span class="pl-k">for</span>(<span class="pl-k">int</span> i=<span class="pl-c1">1</span>;i&lt;=q;i++){
		<span class="pl-k">int</span> x,y;
		cin&gt;&gt;x&gt;&gt;y;
		<span class="pl-k">int</span> p=a[x][y];
		cout&lt;&lt;p&lt;&lt;endl;
		<span class="pl-k">for</span>(<span class="pl-k">int</span> j=y;j&lt;m;j++){
			a[x][j]=a[x][j+<span class="pl-c1">1</span>];
		}
		<span class="pl-k">for</span>(<span class="pl-k">int</span> j=x;j&lt;n;j++){
			a[j][m]=a[j+<span class="pl-c1">1</span>][m];
		}
		a[n][m]=p;
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>结语</h2>
<p>感觉这次考 NOIP 着实让我第一次亲身体验到算法竞赛。我自己认为我在赛场上还是还是发挥得较为成功。不过确实还有许多要学习的知识点、算法和技巧。未来还是要努力的......</p>
<hr>
<p>本文由Markdown书写。样式表、解析器来自 GitHub 。编辑器 MarkdownPad 2 。</p>
<p>This page is under MIT License. Powered by Guyutongxue.</p>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
