<!DOCTYPE html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>干他娘的命令行参数</title>
<link rel="stylesheet" href="/css/markdown.css">
<h1>干他娘的命令行参数</h1>
<p>命令行参数这个东西看上去很简单，但它实际上恶心得很。我随便举一个例子：请向一个程序原样传递如下命令行参数：</p>
<ul>
<li><code>a</code></li>
<li><code>b c</code></li>
<li><code></code></li>
<li><code>&quot;</code></li>
<li><code>\&quot;</code></li>
<li><code>\\&quot;</code></li>
<li><code>\\d</code></li>
<li><code>&quot;e&quot; </code></li>
<li><code> &quot;\f &quot;</code></li>
</ul>
<p>首先明确一点，就是命令行参数的传递方法主要是两种：</p>
<ol>
<li>通过系统调用（操作系统 API），例如 <code>CreateProcessW</code> <code>exec</code> 等；</li>
<li>通过壳层程序（Shell），例如 <code>cmd.exe</code> <code>bash</code> 等。</li>
</ol>
<p>然后，世界上主流的操作系统分为两类，*nix 和 Windows。前者我就用 POSIX 标准代替。那么整个问题就划分为这样四个象限：</p>
<table>
<thead>
<tr>
<th></th>
<th>POSIX</th>
<th>Windows</th>
</tr>
</thead>
<tbody>
<tr>
<td>系统调用</td>
<td><code>exec</code></td>
<td><code>CreateProcessW</code></td>
</tr>
<tr>
<td>壳层</td>
<td>POSIX Shell</td>
<td><code>cmd.exe</code></td>
</tr>
</tbody>
</table>
<p>具体而言：</p>
<ul>
<li><code>exec</code> 系统调用是最简单的：直接向它传入“组织好的” <code>char**</code> 类型变量即可。</li>
<li>POSIX Shell 的命令行转义方式需要参考 POSIX 标准。</li>
<li><code>CreateProcessW</code> 的转义方式需要参考微软文档。</li>
<li><code>cmd.exe</code> 的转义方式也需要参考微软文档（然而根本没有）。</li>
</ul>
<p>本文的后续算法描述使用 JavaScript/TypeScript。</p>
<h2>POSIX Shell</h2>
<blockquote>
<p>参考：<a href="https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/V3_chap02.html">IEEE Std 1003.1-2017 Shell &amp; Utilities 2.2</a></p>
</blockquote>
<h3>从命令行到参数</h3>
<p>首先，POSIX Shell 的命令行是由空格分隔的若干参数。若参数带有空格，则需要用引号括起。</p>
<blockquote>
<p>这些字符在 POSIX Shell 中具有特殊含义：<code>|</code> <code>&amp;</code> <code>;</code> <code>&lt;</code> <code>&gt;</code> <code>(</code> <code>)</code> <code>$</code> <code>`</code> <code>\</code> <code>&quot;</code> <code>'</code> <code> </code> Tab 和换行符。所以若参数包含它们，则必须要括起。</p>
</blockquote>
<p>其中，主要有两种括起方式：单引号和双引号。单引号是由天然缺陷的：单引号内部的参数不能再出现单引号，所以这里不提及它；双引号括起的命令行参数是完备的。</p>
<p>双引号内的所有字符都会原样作为参数，以下字符除外：</p>
<ul>
<li>美元符号 <code>$</code>。美元符号会作为变量（如 <code>$PATH</code>）、命令展开（如 <code>$(date)</code>）或算术表达式（如 <code>$((1 + 1))</code> 的前缀。</li>
<li>反引号 <code>`</code>。反引号同样是命令展开的前缀。</li>
<li>反斜杠 <code>\</code>。当反斜杠的尾随字符为 <code>$</code>、<code>`</code>、<code>&quot;</code>、<code>\</code> 或换行符时，两者整体视为单个字符。</li>
</ul>
<h3>从参数到命令行</h3>
<p>根据上述规则，推算出反向算法为：</p>
<pre><code class="language-ts">function argvToShell(argv: string[]) {
    let cmd = &quot;&quot;;
    for (const arg of argv) {
        cmd += &quot;\&quot;&quot;;
        for (const c of arg) {
            if (&quot;$`\&quot;\\&quot;].includes(c)) {
                cmd += &quot;\\&quot;;
                cmd += c;
            } else {
                cmd += c;
            }
        }
        cmd += &quot;\&quot; &quot;;
    }
    return cmd;
}
</code></pre>
<p>这个规则非常简洁；也可以直接用正则表达式：</p>
<pre><code class="language-ts">function argvToShell(argv: string[]) {
  return argv
    .map((arg) =&gt; `&quot;${arg.replace(/(\$|`|&quot;|\\)/g, &quot;\\$1&quot;)}&quot;`)
    .join(&quot; &quot;);
}
</code></pre>
<h2><code>CreateProcessW</code></h2>
<p>POSIX 简洁的设计让人感到欣慰，但 Windows 这边就痛苦起来了。最核心的问题就在于：Windows 的 <code>CreateProcessW</code>（或者 ANSI 版本的 <code>CreateProcessA</code>）是传递整条命令行的，而不是命令行参数！</p>
<pre><code class="language-c">BOOL CreateProcessW(
  LPCWSTR               lpApplicationName,
  LPWSTR                lpCommandLine,       /* 这里，指向一整行命令行 */
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL                  bInheritHandles,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCWSTR               lpCurrentDirectory,
  LPSTARTUPINFOW        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<p>不同于 <code>exec</code>，Windows 只能通过一整行命令行启动进程。而如何将命令行解释为若干参数，是被启动的进程自主解释的！不过，微软定义了一种及其别扭的解释方式，Visual C++ 和 .NET Framework 都遵循这个规则提供 <code>argc/argv/args</code> 的值。</p>
<p>下文内容均按照这种解释方式。</p>
<h3>从命令行到参数</h3>
<blockquote>
<p>参考：</p>
<ul>
<li>Visual C++: <a href="https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw"><code>CommandLineToArgvW</code></a></li>
<li>.NET Framework: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.environment.getcommandlineargs?view=netframework-4.8#system-environment-getcommandlineargs"><code>Environment.GetCommandLineArgs</code></a></li>
</ul>
</blockquote>
<p>微软定义的规则时这样说的：</p>
<ul>
<li>解析命令行时，程序在两种状态切换：引号外状态和引号内状态。</li>
<li>初始的状态是引号外状态。</li>
<li>当处于引号外状态时遇到空白字符，视为当前参数的结束。下一个非空白字符视为下一参数的开始。</li>
<li>当处于引号内状态时，空白字符与普通字符同样对待。</li>
<li>当遇到 $n$ 个反斜杠 <code>\</code> 时（不论处于何种状态）：
<ul>
<li>若 $n$ 个反斜杠后的字符不是 <code>&quot;</code>，则仍然将这 $n$ 个反斜杠视为普通字符。</li>
<li>若 $n$ 个反斜杠后的字符时 <code>&quot;</code>，则：
<ul>
<li>若 $n\equiv0\pmod2$，则首先将这 $n$ 个反斜杠视为 $\dfrac n2$ 个反斜杠普通字符。随后，丢弃尾随 <code>&quot;</code> 并切换状态。（注意：此时不会将 <code>&quot;</code> 字符视为任何参数的一部分。）</li>
<li>若 $n\equiv1\pmod2$，则首先将这 $n$ 个反斜杠视为 $\dfrac {n-1}2$ 个反斜杠普通字符。随后，将剩余的 <code>\&quot;</code> 视为单个双引号普通字符。不切换状态。</li>
</ul>
</li>
</ul>
</li>
<li>遇到 <code>&quot;</code> 但没有前缀的 <code>\</code> 时，视为 $0$ 个 <code>\</code> 加一个 <code>&quot;</code>，即“丢弃 <code>&quot;</code> 并切换状态”。</li>
</ul>
<blockquote>
<p>此外，这个规则还包含一些例外，这里暂时先忽略。</p>
<ul>
<li>位于命令行最开头的连续个空白字符被视为一个额外的空参数。</li>
<li>在引号内状态下，允许使用两个双引号作为单个双引号的转义。
<ul>
<li>在 <code>msvcr80.dll</code> （Microsoft Visual C++ 2008 Redistributable）及更早版本的运行时库中，在引号外状态下也会应用两个双引号的转义。</li>
</ul>
</li>
</ul>
<p>——感谢知友 @王扶之 提供的补充</p>
</blockquote>
<h3>从参数到命令行</h3>
<p>根据上述规则，推算出反向算法为：</p>
<pre><code class="language-ts">function argvToCommandLine(argv: string[]) {
  let cmd = &quot;&quot;;
  for (const arg of argv) {
    cmd += '&quot;';
    for (let i = 0; true; i++) {
      // 记录已经连续了多少个反斜杠
      let slashNum = 0;
      while (i !== arg.length &amp;&amp; arg[i] === &quot;\\&quot;) {
        i++;
        slashNum++;
      }
      if (i === arg.length) {
        cmd += &quot;\\&quot;.repeat(slashNum * 2);
        break;
      } else if (arg[i] === '&quot;') {
        cmd += &quot;\\&quot;.repeat(slashNum * 2 + 1);
        cmd += '&quot;';
      } else {
        cmd += &quot;\\&quot;.repeat(slashNum);
        cmd += arg[i];
      }
    }
    cmd += '&quot; ';
  }
  return cmd;
}
</code></pre>
<p>在 <a href="https://github.com/libuv/libuv/blob/d54c92e3e68f0b8152617d8e97f704dd1e586bd6/src/win/process.c#L455">libuv</a> 中有另一种更简单的实现（感谢知友 @王扶之 提供的资料）：</p>
<pre><code class="language-ts">function argvToCommandLine(argv: string[]) {
  return argv
    .map((arg) =&gt; {
      let rev = '&quot;'; // 逆向构造
      let quoteHit = true; // 是否处于保留引号的区间
      for (let i = arg.length - 1; i &gt;= 0; i--) {
        rev += arg[i];
        if (quoteHit &amp;&amp; arg[i] === &quot;\\&quot;) {
          // 若需要保留引号，则添加额外的反斜杠
          rev += &quot;\\&quot;;
        } else if (arg[i] === '&quot;') {
          quoteHit = true;
          rev += &quot;\\&quot;;
        } else {
          quoteHit = false;
        }
      }
      rev += '"';
      // 反转为正向字符串
      return Array.from(rev).reverse().join(&quot;&quot;);
    })
    .join(&quot; &quot;);
}
</code></pre>
<p>不得不说，这个规则实在太古怪，比如 <code>\\&quot;</code> 和 <code>\\d</code> 的正确括起写法分别是 <code>&quot;\\\\\&quot;&quot;</code> 和 <code>&quot;\\d&quot;</code>；反斜杠的数量有天壤之别。</p>
<h2>cmd.exe</h2>
<p>还有更恶心的。Windows 的默认壳层程序 cmd.exe 用了更糟糕的解析规则，而且这个规则还没有官方的文档。</p>
<blockquote>
<p>好在神通广大的网友们通过大量试验逆向出了这个规则。本节参考：<a href="https://stackoverflow.com/a/4095133/14053503">Stack Overflow</a></p>
</blockquote>
<h3>命令行到参数</h3>
<p>cmd.exe 的任务是解析用户的输入，理解诸如控制语句、IO 重定向等信息。对我们而言，最重要的是运行外部程序时的两部分内容：目标程序和参数命令行。</p>
<ul>
<li>cmd.exe 的第一阶段工作是将输入按回车分成若干行。</li>
<li>cmd.exe 的第二阶段工作是展开每一行中的变量。
<ul>
<li>在这一步中，所有 <code>%</code> 开头的字符都会被特殊处理。处理后是否保留 <code>%</code> 字符是复杂的。</li>
</ul>
</li>
<li>cmd.exe 的第三阶段是：将一行输入分解为若干词法标记（Token）。这是重点。</li>
<li>（先暂时跳过第三阶段的解释，）当分析完成后：
<ul>
<li>将重定向子句（<code>&lt;</code> <code>&gt;</code>）移动到本行末尾；</li>
<li>将管道运算符（<code>|</code>）、命令衔接符（<code>&amp;</code> <code>&amp;&amp;</code> <code>||</code>）视为多行输入；</li>
<li>将静默修饰符（<code>@</code>）移除；</li>
<li>完成这些处理后的第一个词法标记就是目标程序（如果这个词法标记不含任何 <code>&quot;</code>，则同时会考虑内置命令）。</li>
<li>除重定向子句外的所有词法标记合起来就是参数命令行。</li>
</ul>
</li>
<li>第三阶段的具体步骤是这样的：
<ul>
<li>分析程序处于两个状态之一：引号内状态或引号外状态。</li>
<li>初始的状态是引号外状态。</li>
<li>任何状态下遇到字符 <code>^</code>，则取消接下来字符的特殊含义（即“被转义”）。带有特殊含义的字符包括 <code>^</code> <code>"</code> <code>(</code> <code>@</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>&gt;</code> <code>;</code> <code>,</code> <code>=</code> <code> </code> Tab、回车和一些其它控制字符，但回车符不能被转义。</li>
<li>任何状态下遇到字符 <code>&quot;</code>，切换程序状态（已经被转义的除外）。</li>
<li>处于引号外状态时：
<ul>
<li>遇到 <code>;</code> <code>,</code> <code>=</code> <code> </code> Tab、回车和一些其它控制字符时，在此处分隔词法标记。</li>
<li>处理特殊含义（已经被转义的除外）：
<ul>
<li>遇到 <code>&lt;</code> <code>&gt;</code> <code>&amp;</code> <code>|</code> 等字符时，处理它们的特殊含义；</li>
<li>（将重定向子句移动后）首个字符处遇到 <code>@</code> 时，处理其特殊含义。</li>
<li>处理位于词法标记开头的 <code>:</code> 的特殊含义。</li>
<li>若组成了记作 <code>IF</code> <code>FOR</code> 或 <code>REM</code> 的词法标记，进入特殊的语法处理。</li>
<li>处理括号 <code>(</code>。</li>
</ul>
</li>
</ul>
</li>
<li>处于引号内状态时：
<ul>
<li>遇到回车时，立即切换到引号外状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总的来说，明确这些要点：</p>
<ul>
<li>虽然 cmd.exe 也使用“引号内”“引号外”状态，但它绝不移除任何引号。所有的引号都会保留到最后一步。</li>
<li>cmd.exe 不认为 <code>\</code> 字符有特殊含义。</li>
<li>对于大部分的特殊字符（包括 <code>&quot;</code>），只需要用 <code>^</code> 转义掉即可。但例外是 <code>^</code> 处理之前的两个步骤：
<ul>
<li>换行符、回车符总是会被忽略。（换而言之，你无法在 cmd.exe 中传入带有换行符的参数。）</li>
<li><code>%</code> 的处理。通用的解决办法是，若 <code>%</code> 不在行尾，则添加一个 <code>^</code> 来取消变量展开。若 <code>%</code> 在行尾，则不用管它。</li>
</ul>
</li>
<li>cmd.exe 得到目标程序的名字后，会移除其中所有的 <code>&quot;</code>（Windows 不允许文件名出现 <code>&quot;</code>），在工作目录和 <code>%Path%</code> 中寻找并执行。</li>
<li>cmd.exe 得到完整的命令行后，会将它传递给目标程序。如果目标程序用 C/C++/C# 编写，就会按照之前提到的规则解析为若干命令行参数。</li>
</ul>
<p>可以看到，cmd.exe 是混乱邪恶的。<strong>为此我强烈呼吁：永远不要用 cmd.exe 传递参数。</strong></p>
<h3>参数到命令行</h3>
<p>但是编程的时候总是会有意无意地碰到 cmd.exe 这块硬骨头。最简单的手段也是最极端的手段：在每个字符前都添加 <code>^</code>——幸好 <code>^</code> 只是取消特殊含义，<code>^</code> 作用于普通的字符上没有效果也不会报错。</p>
<pre><code class="language-ts">function argvToCmdDotExe(argv: string[]) {
  if (argv.join('').includes(&quot;\n&quot;)) {
    throw new Error(`别想了，这事儿不能成`);
  }
  return argvToCommandLine(argv).replace(/(.)/g, &quot;^$1&quot;);
}
</code></pre>
<h2>附录：程序名</h2>
<p>说完了参数解析，程序名的解析就相对简单了。</p>
<table>
<thead>
<tr>
<th></th>
<th>POSIX</th>
<th>Windows</th>
</tr>
</thead>
<tbody>
<tr>
<td>系统调用</td>
<td><code>exec</code> 的首个参数原样传递</td>
<td>见下文</td>
</tr>
<tr>
<td>壳层</td>
<td>规则和参数相同</td>
<td>首个词法标记，并删除双引号</td>
</tr>
</tbody>
</table>
<p><code>CreateProcessW</code> 虽然提供了用作程序名的首个参数，但一般习惯设置为空（<code>NULL</code> 或 <code>nullptr</code>）。要启动的程序名一般通过如下解析规则获取：</p>
<ul>
<li>检查命令行的首个字符。若它不是 <code>&quot;</code>：
<ul>
<li>将命令行按照空白字符分割；</li>
<li>以首段内容作为文件名查找程序。若查找到，则执行它。</li>
<li>以首段内容 + 空白字符 + 下一段内容作为文件名查找程序。若查找到，则执行它。</li>
<li>这样一直做下去；如果整段字符串作为文件名仍然找不到，则给出“文件不存在”错误（错误码 <code>2</code>）。</li>
</ul>
</li>
<li>若首个字符是 <code>&quot;</code>：
<ul>
<li>截取第二个字符到下一个 <code>&quot;</code> 字符（不含）为止的子字符串；若没有第二个 <code>&quot;</code>，则截取到字符串结尾。</li>
<li>将该子串作为文件名查找程序。若查找到，则执行它；否则给出“文件不存在”错误。</li>
</ul>
</li>
</ul>
<p>之所以不推荐通过 <code>CreateProcessW</code> 的首个参数传递程序名，是因为如果这样做的话，被启动的进程的命令行就会缺失“程序名”部分——换而言之，被启动的程序的 <code>argv[0]</code> 不再是程序名了！这与 POSIX 标准，以及用户习惯都不吻合。</p>
